// Generated by CodiumAI

import env from '@env/server';
import { FileWrapper } from '@file-upload/admin';
import { expect } from '@storybook/test';
import { renameEventPassNftFiles } from './renameEventPassNftFiles';

jest.mock('@file-upload/admin');

describe('renameEventPassNftFiles', () => {
  const mockCopyFileBatchWithRetry = jest.fn();
  const mockDeleteFilesBatchWithRetry = jest.fn();
  beforeAll(() => {
    // Mock the FileWrapper instance methods
    FileWrapper.prototype.copyFileBatchWithRetry = mockCopyFileBatchWithRetry;
    FileWrapper.prototype.deleteFilesBatchWithRetry =
      mockDeleteFilesBatchWithRetry;
  });

  beforeEach(() => {
    jest.clearAllMocks();
  });

  const filesPath = ['file1.jpg', 'file2.jpg'];
  const organizerId = 'organizer1';
  const eventId = 'event1';
  const eventPassId = 'pass1';

  // It should copy the files to the correct destination folder.
  it('should copy files to correct destination folder', async () => {
    // Act
    await renameEventPassNftFiles({
      filesPath,
      organizerId,
      eventId,
      eventPassId,
    });

    // Assert
    expect(mockCopyFileBatchWithRetry).toHaveBeenCalledWith(
      expect.any(String), // BYTESCALE_ACCOUNT_ID
      [
        {
          source: 'file1.jpg',
          destination: `/${env.UPLOAD_PATH_PREFIX}/organizers/organizer1/events/event1/pass1/event1-pass1-0.jpg`,
        },
        {
          source: 'file2.jpg',
          destination: `/${env.UPLOAD_PATH_PREFIX}/organizers/organizer1/events/event1/pass1/event1-pass1-1.jpg`,
        },
      ],
    );
    expect(mockDeleteFilesBatchWithRetry).toHaveBeenCalledWith(
      expect.any(String), // BYTESCALE_ACCOUNT_ID
      ['file1.jpg', 'file2.jpg'],
    );
  });

  // It should handle an empty array of filesPath.
  it('should handle empty array of filesPath', async () => {
    // Arrange
    const filesPath: string[] = [];
    // Act
    await renameEventPassNftFiles({
      filesPath,
      organizerId,
      eventId,
      eventPassId,
    });

    // Assert
    expect(mockCopyFileBatchWithRetry).not.toHaveBeenCalled();
    expect(mockDeleteFilesBatchWithRetry).not.toHaveBeenCalled();
  });

  // It should handle a non-existent file in filesPath.
  it('should handle non-existent file in filesPath', async () => {
    // Arrange
    const filesPath = ['file1.jpg', 'file2.jpg'];
    const organizerId = 'organizer1';
    const eventId = 'event1';
    const eventPassId = 'pass1';
    (
      FileWrapper.prototype.copyFileBatchWithRetry as jest.Mock
    ).mockRejectedValueOnce(new Error('File does not exist'));
    // Act
    const result = renameEventPassNftFiles({
      filesPath,
      organizerId,
      eventId,
      eventPassId,
    });

    // Assert
    await expect(result).rejects.toThrowError('File does not exist');

    expect(mockDeleteFilesBatchWithRetry).not.toHaveBeenCalled();
  });
});

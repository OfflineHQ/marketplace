// Generated by CodiumAI
import { adminSdk } from '@gql/admin/api';
import { Roles_Enum } from '@gql/shared/types';
import { NextRedis } from '@next/redis';
import { AppUser } from '@next/types';
import { backOfficeAccounts } from '@test-utils/gql';
import { SiweMessage } from 'siwe';
import { RoleAuthorization, RoleInvitationService } from './roles-admin';

jest.mock('@gql/admin/api');

// Mock the SiweMessage class
jest.mock('siwe', () => {
  return {
    SiweMessage: jest.fn().mockImplementation(() => {
      return {
        verify: jest.fn().mockResolvedValue(true), // Mock the verify method to always return true
        nonce: 'nonce',
      };
    }),
  };
});

// Generated by CodiumAI

describe('RoleInvitationService', () => {
  const invitation = {
    nonce: 'nonce',
    role: Roles_Enum.OrganizerAdmin,
    organizerId:
      backOfficeAccounts.alpha_organizer_super_admin_user.role.organizerId,
    eventId: '',
    address: backOfficeAccounts.delta_user.address,
    senderAddress: backOfficeAccounts.alpha_organizer_super_admin_user.address,
    expiration: Date.now() + 60 * 60 * 24 * 1000, // Set expiration to 24 hours from now
  };

  const cacheMock = {
    kv: {
      get: jest.fn(),
      del: jest.fn(),
      set: jest.fn(),
      srem: jest.fn(),
      sadd: jest.fn(),
      smembers: jest.fn(),
    },
  } as unknown as NextRedis;

  const invitationForRoleExistsProps = {
    ...invitation,
    senderAddress: invitation.senderAddress,
    address: invitation.address,
  };

  const acceptInvitationProps = {
    message: 'message',
    signature: 'signature',
    user: backOfficeAccounts.delta_user,
    inviter: backOfficeAccounts.alpha_organizer_super_admin_user,
  };

  const declineInvitationProps = {
    user: backOfficeAccounts.delta_user,
    inviter: backOfficeAccounts.alpha_organizer_super_admin_user,
    nonce: 'nonce',
  };

  const verifyInvitationProps = {
    nonce: 'nonce',
    user: backOfficeAccounts.delta_user,
    senderAddress: backOfficeAccounts.alpha_organizer_super_admin_user.address,
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  // Generated by CodiumAI

  describe('invitationForRoleExists', () => {
    // Should return true if there is an existing invitation for the given inviter, invited, role, organizerId, and eventId
    it('should return true when there is an existing invitation for the given inviter, invited, role, organizerId, and eventId', async () => {
      // Arrange
      const roleInvitationService = new RoleInvitationService(cacheMock);
      // Mock the getInvitationsByInviter method to return a mock invitation
      roleInvitationService.getInvitationsByInviter = jest
        .fn()
        .mockResolvedValue([invitation]);

      // Act
      const result = await roleInvitationService.invitationForRoleExists(
        invitationForRoleExistsProps,
      );

      // Assert
      expect(result).toBe(true);
    });

    // Should return true if the invited user already has the given role for the given organizer and event
    it('should return true when the invited user already has the given role for the given organizer and event', async () => {
      // Arrange
      const roleInvitationService = new RoleInvitationService(cacheMock);

      // Mock the getInvitationsByInviter method to return an empty array
      roleInvitationService.getInvitationsByInviter = jest
        .fn()
        .mockResolvedValue([]);

      // Mock the adminSdk.GetAccountByAddress method to return a mock invited user
      adminSdk.GetAccountByAddress = jest.fn().mockResolvedValue({
        account: [
          {
            id: backOfficeAccounts.delta_user.id,
          },
        ],
      });

      // Mock the adminSdk.GetRoleMinimal method to return a mock role assignment
      adminSdk.GetRoleMinimal = jest.fn().mockResolvedValue({
        roleAssignments: [
          {
            id: 'roleAssignment123',
          },
        ],
      });

      // Act
      const result = await roleInvitationService.invitationForRoleExists(
        invitationForRoleExistsProps,
      );

      // Assert
      expect(result).toBe(true);
    });

    // Check if invitationForRoleExists returns false when the invited user does not have the given role for the given organizer and event.

    // Should return false if the invited user does not have the given role for the given organizer and event
    it('should return false when the invited user does not have the given role for the given organizer and event', async () => {
      // Arrange
      const roleInvitationService = new RoleInvitationService(cacheMock);

      // Mock the getInvitationsByInviter method to return an empty array
      roleInvitationService.getInvitationsByInviter = jest
        .fn()
        .mockResolvedValue([]);

      // Mock the adminSdk.GetAccountByAddress method to return a mock invited user
      adminSdk.GetAccountByAddress = jest.fn().mockResolvedValue({
        account: [
          {
            id: backOfficeAccounts.delta_user.id,
          },
        ],
      });

      // Mock the adminSdk.GetRoleMinimal method to return an empty array
      adminSdk.GetRoleMinimal = jest.fn().mockResolvedValue({
        roleAssignments: [],
      });

      // Act
      const result = await roleInvitationService.invitationForRoleExists(
        invitationForRoleExistsProps,
      );

      // Assert
      expect(result).toBe(false);
    });
  });

  describe('getInvitationsByInviter', () => {
    const invitation1 = {
      nonce: 'nonce1',
      role: Roles_Enum.OrganizerAdmin,
      organizerId: 'organizer1',
      eventId: '',
      address: 'address1',
      senderAddress: 'senderAddress1',
      expiration: Date.now() + 60 * 60 * 24 * 1000,
    };
    const invitation2 = {
      nonce: 'nonce2',
      role: Roles_Enum.OrganizerContentManager,
      organizerId: 'organizer2',
      eventId: '',
      address: 'address2',
      senderAddress: 'senderAddress2',
      expiration: Date.now() + 60 * 60 * 24 * 1000,
    };

    // Should retrieve all invitations for a given inviter address
    it('should retrieve all invitations when there are invitations for the given inviter address', async () => {
      // Arrange
      const nonces = ['nonce1', 'nonce2'];
      (cacheMock.kv.smembers as jest.Mock).mockResolvedValue(nonces);
      const senderAddress = 'exampleInviterAddress';
      const roleInvitationService = new RoleInvitationService(cacheMock);

      jest
        .spyOn(roleInvitationService, 'getInvitationsByInviter')
        .mockResolvedValue([invitation1, invitation2]);
      jest
        .spyOn(roleInvitationService, 'fetchInvitation')
        .mockImplementation((senderAddress, nonce) => {
          if (nonce === 'nonce1') {
            return Promise.resolve(invitation1);
          } else if (nonce === 'nonce2') {
            return Promise.resolve(invitation2);
          } else {
            return Promise.resolve(null);
          }
        });

      // Act
      const result = await roleInvitationService.getInvitationsByInviter({
        senderAddress,
      });

      // Assert
      expect(result).toEqual([invitation1, invitation2]);
    });

    // Should return an empty array if there are no invitations for the given inviter address
    it('should return an empty array when there are no invitations for the given inviter address', async () => {
      // Arrange
      const nonces = [];
      (cacheMock.kv.smembers as jest.Mock).mockResolvedValue(nonces);
      const roleInvitationService = new RoleInvitationService(cacheMock);
      const senderAddress = 'exampleInviterAddress';

      jest
        .spyOn(roleInvitationService, 'getInvitationsByInviter')
        .mockResolvedValue([]);

      // Act
      const result = await roleInvitationService.getInvitationsByInviter({
        senderAddress,
      });

      // Assert
      expect(result).toEqual([]);
    });

    // Should filter out null results from expired or non-existent invitations
    it('should filter out null results from expired or non-existent invitations', async () => {
      // Arrange
      const nonces = ['nonce1', 'nonce2'];
      (cacheMock.kv.smembers as jest.Mock).mockResolvedValue(nonces);
      const roleInvitationService = new RoleInvitationService(cacheMock);
      const senderAddress = 'exampleInviterAddress';

      jest
        .spyOn(roleInvitationService, 'fetchInvitation')
        .mockImplementation((senderAddress, nonce) => {
          if (nonce === 'nonce1') {
            return Promise.resolve(invitation1);
          } else if (nonce === 'nonce2') {
            return Promise.resolve(null);
          } else {
            return Promise.resolve(null);
          }
        });

      // Act
      const result = await roleInvitationService.getInvitationsByInviter({
        senderAddress,
      });

      // Assert
      expect(result).toEqual([invitation1]);
    });
  });

  // Generated by CodiumAI

  describe('fetchInvitation', () => {
    // Should return the invitation object if it exists in the cache and has not expired
    it('should return the invitation object when it exists in the cache and has not expired', async () => {
      // Arrange
      cacheMock.kv.get = jest.fn().mockResolvedValue(invitation);
      const roleInvitationService = new RoleInvitationService(cacheMock);
      // Act
      const result = await roleInvitationService.fetchInvitation(
        backOfficeAccounts.alpha_organizer_super_admin_user.address,
        'nonce',
      );

      // Assert
      expect(result).toEqual(invitation);
    });

    // Should return null if the invitation object does not exist in the cache
    it('should return null when the invitation object does not exist in the cache', async () => {
      // Arrange
      cacheMock.kv.get = jest.fn().mockResolvedValue(null);
      const roleInvitationService = new RoleInvitationService(cacheMock);
      // Act
      const result = await roleInvitationService.fetchInvitation(
        backOfficeAccounts.alpha_organizer_super_admin_user.address,
        'nonce',
      );

      // Assert
      expect(result).toBeNull();
    });

    // Should call 'deleteInvitation' method if the invitation has expired and return null
    it("should call 'deleteInvitation' method if the invitation has expired and return null", async () => {
      // Arrange
      const expiredInvitation = {
        ...invitation,
        expiration: Date.now() - 1000,
      };
      cacheMock.kv.get = jest.fn().mockResolvedValue(expiredInvitation);
      const roleInvitationService = new RoleInvitationService(cacheMock);
      const deleteInvitationSpy = jest.spyOn(
        roleInvitationService,
        'deleteInvitation',
      );
      // Act
      const result = await roleInvitationService.fetchInvitation(
        backOfficeAccounts.alpha_organizer_super_admin_user.address,
        'nonce',
      );

      // Assert
      expect(result).toBeNull();
      expect(deleteInvitationSpy).toHaveBeenCalledWith({
        senderAddress:
          backOfficeAccounts.alpha_organizer_super_admin_user.address,
        nonce: 'nonce',
      });
    });
  });

  // Create an invitation successfully and return a nonce
  it('should create an invitation successfully and return a nonce', async () => {
    // Arrange
    cacheMock.kv.get = jest.fn().mockResolvedValue(invitation);
    const roleInvitationService = new RoleInvitationService(cacheMock);
    const invitationProps = {
      role: Roles_Enum.OrganizerAdmin,
      organizerId: 'organizerId',
      eventId: 'eventId',
      address: 'address',
      senderAddress: 'senderAddress',
      expiration: Date.now() + 60 * 60 * 24 * 1000, // Set expiration to 24 hours from now
    };

    // Act
    const result =
      await roleInvitationService.createInvitation(invitationProps);

    // Assert
    expect(result).toBeDefined();
    expect(cacheMock.kv.set).toHaveBeenCalledWith(
      `invitation:senderAddress:${result}`,
      {
        ...invitationProps,
        expiration: expect.any(Number),
        nonce: result,
      },
    );
    expect(cacheMock.kv.sadd).toHaveBeenCalledWith(
      `inviter_invitations:senderAddress`,
      result,
    );
  });

  // Verify an invitation successfully and return the invitation and inviter
  it('should verify an invitation successfully and return the invitation and inviter', async () => {
    // Arrange
    cacheMock.kv.get = jest.fn().mockResolvedValue(invitation);
    const roleInvitationService = new RoleInvitationService(cacheMock);

    (adminSdk.GetAccountByAddress as jest.Mock).mockResolvedValueOnce({
      account: [backOfficeAccounts.alpha_organizer_super_admin_user],
    });

    // Act
    const result = await roleInvitationService.verifyInvitation(
      verifyInvitationProps,
    );

    // Assert
    expect(result.invitation).toBeDefined();
    expect(result.inviter).toBeDefined();
    expect(cacheMock.kv.get).toHaveBeenCalledWith(
      `invitation:${result.inviter.address}:nonce`,
    );
  });

  // Accept an invitation successfully and assign the role to the user
  it('should accept an invitation successfully and assign the role to the user', async () => {
    // Arrange
    cacheMock.kv.get = jest.fn().mockResolvedValue(invitation);
    const roleInvitationService = new RoleInvitationService(cacheMock);

    // Act
    await roleInvitationService.acceptInvitation(acceptInvitationProps);

    // Assert
    expect(cacheMock.kv.get).toHaveBeenCalledWith(
      `invitation:${backOfficeAccounts.alpha_organizer_super_admin_user.address}:nonce`,
    );
    expect(adminSdk.CreateRoleAssignment as jest.Mock).toHaveBeenCalledWith({
      input: {
        role: Roles_Enum.OrganizerAdmin,
        organizerId:
          backOfficeAccounts.alpha_organizer_super_admin_user.role.organizerId,
        eventId: '',
        accountId: backOfficeAccounts.delta_user.id,
        invitedById: backOfficeAccounts.alpha_organizer_super_admin_user.id,
      },
    });
    expect(cacheMock.kv.del).toHaveBeenCalledWith(
      `invitation:${backOfficeAccounts.alpha_organizer_super_admin_user.address}:nonce`,
    );
    expect(cacheMock.kv.srem).toHaveBeenCalledWith(
      `inviter_invitations:${backOfficeAccounts.alpha_organizer_super_admin_user.address}`,
      'nonce',
    );
  });

  // Decline an invitation successfully and remove it from the cache
  it('should decline an invitation successfully and remove it from the cache', async () => {
    // Arrange
    cacheMock.kv.get = jest.fn().mockResolvedValue(invitation);
    const roleInvitationService = new RoleInvitationService(cacheMock);
    const declineInvitationProps = {
      user: backOfficeAccounts.delta_user,
      inviter: backOfficeAccounts.alpha_organizer_super_admin_user,
      nonce: 'nonce',
    };

    // Act
    await roleInvitationService.declineInvitation(declineInvitationProps);

    // Assert
    expect(cacheMock.kv.get).toHaveBeenCalledWith(
      `invitation:${backOfficeAccounts.alpha_organizer_super_admin_user.address}:nonce`,
    );
    expect(cacheMock.kv.del).toHaveBeenCalledWith(
      `invitation:${backOfficeAccounts.alpha_organizer_super_admin_user.address}:nonce`,
    );
    expect(cacheMock.kv.srem).toHaveBeenCalledWith(
      `inviter_invitations:${backOfficeAccounts.alpha_organizer_super_admin_user.address}`,
      'nonce',
    );
  });
  // Throw an error when accepting an invitation with wrong SIWE signature
  it('should throw an error when accepting an invitation with invalid SIWE signature', async () => {
    // Arrange
    const roleInvitationService = new RoleInvitationService(cacheMock);

    (SiweMessage as jest.Mock).mockImplementationOnce(() => {
      return {
        verify: jest.fn().mockResolvedValue(false), // Mock the verify method to always return false
        nonce: 'nonce',
      };
    });

    // Act & Assert
    await expect(
      roleInvitationService.acceptInvitation(acceptInvitationProps),
    ).rejects.toThrow('Invalid SIWE message signature.');
  });

  it('should throw an error when accepting an invitation with invalid address', async () => {
    // Arrange
    const cacheMock = {
      kv: {
        get: jest.fn().mockResolvedValue({
          nonce: 'nonce',
          role: Roles_Enum.OrganizerAdmin,
          organizerId:
            backOfficeAccounts.alpha_organizer_super_admin_user.role
              .organizerId,
          address: 'wrong_address',
          senderAddress:
            backOfficeAccounts.alpha_organizer_super_admin_user.address,
        }),
        del: jest.fn(),
        set: jest.fn(),
      },
    } as unknown as NextRedis;

    const roleInvitationService = new RoleInvitationService(cacheMock);

    // Act & Assert
    await expect(
      roleInvitationService.acceptInvitation(acceptInvitationProps),
    ).rejects.toThrow('Invalid or expired invitation.');
  });

  it('should throw an error when accepting an invitation that is not in cache anymore', async () => {
    // Arrange
    const cacheMock = {
      kv: {
        get: jest.fn().mockResolvedValue(null),
        del: jest.fn(),
        set: jest.fn(),
      },
    } as unknown as NextRedis;

    const roleInvitationService = new RoleInvitationService(cacheMock);

    // Act & Assert
    await expect(
      roleInvitationService.acceptInvitation(acceptInvitationProps),
    ).rejects.toThrow('Invalid or expired invitation.');
  });

  // Throw an error when declining an invitation with invalid input
  it('should throw an error when declining an invitation with invalid address', async () => {
    // Arrange
    const cacheMock = {
      kv: {
        get: jest.fn().mockResolvedValue({
          nonce: 'nonce',
          role: Roles_Enum.OrganizerAdmin,
          organizerId:
            backOfficeAccounts.alpha_organizer_super_admin_user.role
              .organizerId,
          address: 'wrong_address',
          senderAddress:
            backOfficeAccounts.alpha_organizer_super_admin_user.address,
        }),
        del: jest.fn(),
        set: jest.fn(),
      },
    } as unknown as NextRedis;
    const roleInvitationService = new RoleInvitationService(cacheMock);

    // Act & Assert
    await expect(
      roleInvitationService.declineInvitation(declineInvitationProps),
    ).rejects.toThrow('Invalid or expired invitation.');
  });

  // Throw an error when verifying an invitation with invalid address
  it('should throw an error when verifying an invitation with invalid address', async () => {
    // Arrange
    const cacheMock = {
      kv: {
        get: jest.fn().mockResolvedValue({
          nonce: 'nonce',
          role: Roles_Enum.OrganizerAdmin,
          organizerId:
            backOfficeAccounts.alpha_organizer_super_admin_user.role
              .organizerId,
          address: 'wrong_address',
          senderAddress:
            backOfficeAccounts.alpha_organizer_super_admin_user.address,
        }),
        del: jest.fn(),
        set: jest.fn(),
      },
    } as unknown as NextRedis;
    const roleInvitationService = new RoleInvitationService(cacheMock);

    // Act & Assert
    await expect(
      roleInvitationService.verifyInvitation(verifyInvitationProps),
    ).rejects.toThrow('Invalid or expired invitation.');
  });

  // Throw an error when verifying an invitation that is not in cache anymore
  it('should throw an error when verifying an invitation that is not in cache anymore', async () => {
    // Arrange
    const cacheMock = {
      kv: {
        get: jest.fn().mockResolvedValue(null),
        del: jest.fn(),
        set: jest.fn(),
      },
    } as unknown as NextRedis;
    const roleInvitationService = new RoleInvitationService(cacheMock);

    // Act & Assert
    await expect(
      roleInvitationService.verifyInvitation(verifyInvitationProps),
    ).rejects.toThrow('Invalid or expired invitation.');
  });

  // Throw an error when declining an invitation that is not in cache anymore
  it('should throw an error when declining an invitation that is not in cache anymore', async () => {
    // Arrange
    const cacheMock = {
      kv: {
        get: jest.fn().mockResolvedValue(null),
        del: jest.fn(),
        set: jest.fn(),
      },
    } as unknown as NextRedis;
    const roleInvitationService = new RoleInvitationService(cacheMock);

    // Act & Assert
    await expect(
      roleInvitationService.declineInvitation(declineInvitationProps),
    ).rejects.toThrow('Invalid or expired invitation.');
  });
});

describe('RoleAuthorization', () => {
  describe('inviteAccountWithRole', () => {
    // Inviting a user with a valid role and organizer ID as a super admin returns true
    it('should return true when inviting a user with a valid role and organizer ID as a super admin', async () => {
      const roleAuthorization = new RoleAuthorization();
      const user = {
        ...backOfficeAccounts.alpha_organizer_super_admin_user,
        role: {
          role: Roles_Enum.OrganizerSuperAdmin,
          organizerId: 'organizer123',
          eventId: '',
        },
      };
      const result = await roleAuthorization.inviteAccountWithRole({
        user,
        role: Roles_Enum.OrganizerGuest,
        organizerId: 'organizer123',
      });
      expect(result).toBe(true);
    });

    // Inviting a user with a valid role and organizer ID as a human resources manager returns true if the role is not super admin or human resources
    it('should return true when inviting a user with a valid role and organizer ID as a human resources manager', async () => {
      const roleAuthorization = new RoleAuthorization();
      const user = {
        ...backOfficeAccounts.alpha_organizer_super_admin_user,
        role: {
          role: Roles_Enum.OrganizerHumanResources,
          organizerId: 'organizer123',
          eventId: '',
        },
      };
      const result = await roleAuthorization.inviteAccountWithRole({
        user,
        role: Roles_Enum.OrganizerGuest,
        organizerId: 'organizer123',
        eventId: '',
      });
      expect(result).toBe(true);
    });

    it('should return false inviting a user with super admin or human resources as a human resources manager', async () => {
      const roleAuthorization = new RoleAuthorization();
      const user = {
        ...backOfficeAccounts.alpha_organizer_super_admin_user,
        role: {
          role: Roles_Enum.OrganizerHumanResources,
          organizerId: 'organizer123',
          eventId: '',
        },
      };
      const result = await roleAuthorization.inviteAccountWithRole({
        user,
        role: Roles_Enum.OrganizerHumanResources,
        organizerId: 'organizer123',
      });
      expect(result).toBe(false);

      const result2 = await roleAuthorization.inviteAccountWithRole({
        user,
        role: Roles_Enum.OrganizerSuperAdmin,
        organizerId: 'organizer123',
      });
      expect(result2).toBe(false);
    });

    // Inviting a user with no role throws an error
    it('should throw an error when inviting a user with no role', async () => {
      const roleAuthorization = new RoleAuthorization();
      const user = {};
      await expect(
        roleAuthorization.inviteAccountWithRole({
          user: user as AppUser,
          role: Roles_Enum.OrganizerGuest,
          organizerId: 'organizer123',
        }),
      ).rejects.toThrow("User doesn't have a role");
    });

    // Inviting a user with a role for a different organizer throws an error
    it('should throw an error when inviting a user with a role for a different organizer', async () => {
      const roleAuthorization = new RoleAuthorization();
      const user = {
        ...backOfficeAccounts.alpha_organizer_super_admin_user,
        role: {
          role: Roles_Enum.OrganizerSuperAdmin,
          organizerId: 'organizer456',
          eventId: '',
        },
      };
      await expect(
        roleAuthorization.inviteAccountWithRole({
          user,
          role: Roles_Enum.OrganizerGuest,
          organizerId: 'organizer123',
        }),
      ).rejects.toThrow("User doesn't have a role for this organizer");
    });

    // Inviting a user with an invalid role throws an error
    it('should throw an error when inviting a user with an invalid role', async () => {
      const roleAuthorization = new RoleAuthorization();
      const user = {
        ...backOfficeAccounts.alpha_organizer_super_admin_user,
        role: {
          role: Roles_Enum.OrganizerSuperAdmin,
          organizerId: 'organizer123',
          eventId: '',
        },
      };
      await expect(
        roleAuthorization.inviteAccountWithRole({
          user,
          role: 'invalidRole' as Roles_Enum,
          organizerId: 'organizer123',
        }),
      ).rejects.toThrow('Invalid role');
    });
  });
  describe('readAndWritePassesFile', () => {
    const user = {
      ...backOfficeAccounts.alpha_organizer_super_admin_user,
      role: {
        role: Roles_Enum.OrganizerSuperAdmin,
        organizerId: 'organizer123',
        eventId: '',
      },
    };
    const roleAuthorization = new RoleAuthorization();
    it('should return true for OrganizerSuperAdmin role', async () => {
      user.role.role = Roles_Enum.OrganizerSuperAdmin;
      const result = await roleAuthorization.readAndWritePassesFile(user);
      expect(result).toBe(true);
    });

    it('should return true for OrganizerAdmin role', async () => {
      user.role.role = Roles_Enum.OrganizerAdmin;
      const result = await roleAuthorization.readAndWritePassesFile(user);
      expect(result).toBe(true);
    });

    it('should return false for other roles', async () => {
      user.role.role = Roles_Enum.OrganizerValidator;
      const result = await roleAuthorization.readAndWritePassesFile(user);
      expect(result).toBe(false);
    });
  });

  describe('readOrganizerEventManagement', () => {
    const user = {
      ...backOfficeAccounts.alpha_organizer_super_admin_user,
      role: {
        role: Roles_Enum.OrganizerSuperAdmin,
        organizerId: 'organizer123',
        eventId: '',
      },
    };
    const roleAuthorization = new RoleAuthorization();
    it('should return false for OrganizerValidator role', async () => {
      user.role.role = Roles_Enum.OrganizerValidator;
      const result = await roleAuthorization.readOrganizerEventManagement(user);
      expect(result).toBe(false);
    });

    it('should return false for OrganizerHumanResources role', async () => {
      user.role.role = Roles_Enum.OrganizerHumanResources;
      const result = await roleAuthorization.readOrganizerEventManagement(user);
      expect(result).toBe(false);
    });

    it('should return true for other roles', async () => {
      user.role.role = Roles_Enum.OrganizerAdmin;
      const result = await roleAuthorization.readOrganizerEventManagement(user);
      expect(result).toBe(true);
    });
  });
});

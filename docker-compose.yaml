version: '3.9'
services:
  hasura-engine:
    container_name: hasura-engine
    image: hasura/graphql-engine:v2.11.2
    ports:
      - '8080:8080'
    depends_on:
      db:
        condition: service_healthy
    env_file:
      - .env.local
    environment:
      HASURA_GRAPHQL_ENABLE_CONSOLE: 'false'
      HASURA_GRAPHQL_DEV_MODE: 'true'
      HASURA_GRAPHQL_ENABLED_LOG_TYPES: startup, http-log, webhook-log, websocket-log, query-log
      HASURA_GRAPHQL_ENABLE_TELEMETRY: 'false'
    healthcheck:
      test:
        [
          'CMD-SHELL',
          'apt-get update -y && apt-get install -y curl && curl --fail http://localhost:8080/healthz || exit 1',
        ]
      interval: 5s
      timeout: 3s
      retries: 30
    networks:
      - web
      - db
    labels:
      - 'traefik.enable=true'
      - 'traefik.docker.network=web'
      - 'traefik.http.routers.hasura-engine.rule=Host(`hasura-engine.postgres.test`)'
    # tty: true
    restart: unless-stopped
    extra_hosts:
      - 'host.docker.internal:host-gateway'

  hasura-console:
    container_name: hasura-console
    image: sebpalluel/hasura_cli_with_socat_and_curl:latest
    # build:
    #   context: ./hasura
    #   dockerfile: Dockerfile
    volumes:
      - ./hasura:/usr/src/hasura
    env_file:
      - .env.local
    environment:
      HASURA_GRAPHQL_ADDRESS: 127.0.0.1
      HASURA_RUN_CONSOLE: 'true'
    ports:
      - '9695:9695'
      - '9693:9693'
    extra_hosts:
      - 'host.docker.internal:host-gateway'
    networks:
      - web
      - db
    labels:
      - 'traefik.enable=true'
      - 'traefik.docker.network=web'
      - 'traefik.http.services.hasura-console.loadbalancer.server.port=9695'
      - 'traefik.http.routers.hasura-console.rule=Host(`hasura-console.postgres.test`)'
    depends_on:
      db:
        condition: service_healthy
    command: './start.sh'
    # tty: true
    restart: unless-stopped

  idpkit:
    container_name: idpkit
    image: waltid/idpkit:latest # backend docker image
    command:
      - run
    env_file:
      - .env.local
    networks:
      - web
    environment:
      WALTID_WALLET_BACKEND_BIND_ADDRESS: 0.0.0.0
      WALTID_WALLET_BACKEND_PORT: 9080
    volumes:
      - ./waltid-idpkit/config:/waltid-idpkit/data-root/config # import config files for idp, nft, verifier.
      - ./waltid-idpkit/data/OIDC:/waltid-idpkit/data-root/data/OIDC # import pub/sec RSA-256 key for OIDC + registered OIDC client
    ports:
      - '9080:9080'
    extra_hosts:
      - 'host.docker.internal:host-gateway'

  mailhog:
    container_name: mailhog
    image: mailhog/mailhog
    logging:
      driver: 'none' # disable saving logs
    ports:
      - '1025:1025' # smtp server
      - '8025:8025' # mailcatcher web interface
    networks:
      - web
    extra_hosts:
      - 'host.docker.internal:host-gateway'
    env_file:
      - .env.local
    restart: on-failure

  db:
    container_name: db
    image: postgres:13
    volumes:
      - db_data:/var/lib/postgresql/data
    ports:
      - '5432:5432'
    networks:
      - db
    restart: unless-stopped
    env_file:
      - .env.local
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U postgres']
      interval: 2s
      timeout: 2s
      retries: 10
    extra_hosts:
      - 'host.docker.internal:host-gateway'

  keycloak-db:
    container_name: keycloak-db
    image: postgres:13
    command: postgres -p $KEYCLOAK_DB_PORT
    volumes:
      - keycloak_db_data:/var/lib/postgresql/data
    ports:
      - '$KEYCLOAK_DB_PORT:$KEYCLOAK_DB_PORT'
    networks:
      - db
    restart: unless-stopped
    env_file:
      - .env.local
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -p $KEYCLOAK_DB_PORT -U postgres']
      interval: 2s
      timeout: 2s
      retries: 10
    extra_hosts:
      - 'host.docker.internal:host-gateway'

  # https://github.com/eabykov/keycloak-compose
  keycloak:
    container_name: keycloak
    image: quay.io/keycloak/keycloak:${KEYCLOAK_VERSION}
    env_file:
      - .env.local
    environment:
      KC_FEATURES: authorization
        token-exchange
        docker
        impersonation
        scripts
        upload-scripts
        web-authn
        client-policies
        dynamic-scopes
    volumes:
      - ./keycloak/master-realm.json:/opt/keycloak/data/import/master-realm.json:ro
    ports:
      - ${KEYCLOAK_PORT}:${KEYCLOAK_PORT}
      - '8443:8443'
    depends_on:
      db:
        condition: service_healthy
    healthcheck:
      test: ['CMD', 'curl', '--fail', 'http://localhost:8100/auth/health/ready']
    networks:
      - web
      - db
    restart: unless-stopped
    # Force the import of master realm at startup to keep same config accross different env
    # https://keepgrowing.in/tools/keycloak-in-docker-2-how-to-import-a-keycloak-realm/
    command:
      [
        '-Djboss.socket.binding.port-offset=100',
        '-Dkeycloak.migration.action=import',
        '-Dkeycloak.migration.provider=singleFile',
        '-Dkeycloak.migration.realmName=master',
        '-Dkeycloak.migration.file=/opt/keycloak/data/import/master-realm.json',
        'start-dev',
        '--http-port=${KEYCLOAK_PORT}',
      ]
    # tty: true
    extra_hosts:
      - 'host.docker.internal:host-gateway'

  # # Used to have same DNS in docker and on the host machine
  # dps:
  #   image: defreitas/dns-proxy-server
  #   volumes:
  #     - /var/run/docker.sock:/var/run/docker.sock
  #     - /etc/resolv.conf:/etc/resolv.conf
  #   environment:
  #     - MG_LOG_LEVEL=ERROR
  #   hostname: dns.mageddo
  #   networks:
  #     dps:
  #       ipv4_address: 172.0.0.10

volumes:
  db_data:
  keycloak_db_data:

networks:
  web:
    driver: bridge
  db:
    driver: bridge
